// Simple 2D point struct
struct Point {
    x: f32;
    y: f32;
}

// 3D vector struct
struct Vec3 {
    x: f32;
    y: f32;
    z: f32;
}

// Struct with mixed types
struct Person {
    age: i32;
    height: f32;
    id: i64;
}

// Test 1: Basic struct creation and field access
fun test_basic_struct(): i32 {
    let p: Point = Point { x: 10.0, y: 20.0 };
    let x_val: f32 = p.x;
    let y_val: f32 = p.y;
    
    // Return non-zero if values are correct
    if (x_val > 9.0) {
        if (y_val > 19.0) {
            return 1;
        }
    }
    return 0;
}

// Test 2: Struct field assignment
fun test_field_assignment(): i32 {
    let p: Point = Point { x: 1.0, y: 2.0 };
    p.x = 100.0;
    p.y = 200.0;
    
    if (p.x > 99.0) {
        if (p.y > 199.0) {
            return 1;
        }
    }
    return 0;
}

// Test 3: Pointer to struct
fun test_struct_pointer(): i32 {
    let p: Point = Point { x: 5.0, y: 10.0 };
    let ptr: Point* = &p;
    
    let x_through_ptr: f32 = (*ptr).x;
    let y_through_ptr: f32 = (*ptr).y;
    
    if (x_through_ptr > 4.0) {
        if (y_through_ptr > 9.0) {
            return 1;
        }
    }
    return 0;
}

// Test 4: Modifying through pointer
fun test_modify_through_pointer(): i32 {
    let p: Point = Point { x: 1.0, y: 2.0 };
    let ptr: Point* = &p;
    
    (*ptr).x = 50.0;
    (*ptr).y = 60.0;
    
    if (p.x > 49.0) {
        if (p.y > 59.0) {
            return 1;
        }
    }
    return 0;
}

// Test 5: Heap allocated struct
fun test_heap_struct(): i32 {
    let ptr: Point* = malloc<Point>(1);
    
    (*ptr).x = 7.0;
    (*ptr).y = 14.0;
    
    let x_val: f32 = (*ptr).x;
    let y_val: f32 = (*ptr).y;
    
    free(ptr);
    
    if (x_val > 6.0) {
        if (y_val > 13.0) {
            return 1;
        }
    }
    return 0;
}

// Test 6: Multiple structs
fun test_multiple_structs(): i32 {
    let p1: Point = Point { x: 1.0, y: 2.0 };
    let p2: Point = Point { x: 3.0, y: 4.0 };
    
    let sum_x: f32 = p1.x + p2.x;
    let sum_y: f32 = p1.y + p2.y;
    
    if (sum_x > 3.0) {
        if (sum_y > 5.0) {
            return 1;
        }
    }
    return 0;
}

// Test 7: Struct with different types
fun test_mixed_types(): i32 {
    let person: Person = Person { age: 25, height: 5.9, id: 12345 };
    
    let age: i32 = person.age;
    let height: f32 = person.height;
    let id: i64 = person.id;
    
    if (age == 25) {
        if (height > 5.0) {
            if (id > 12000) {
                return 1;
            }
        }
    }
    return 0;
}

// Test 8: Struct in a loop
fun test_struct_in_loop(): i32 {
    let p: Point = Point { x: 0.0, y: 0.0 };
    
    for (let i = 0; i < 5; i = i + 1) {
        p.x = p.x + 1.0;
        p.y = p.y + 2.0;
    }
    
    // After loop: x = 5.0, y = 10.0
    if (p.x > 4.0) {
        if (p.y > 9.0) {
            return 1;
        }
    }
    return 0;
}

// Test 9: Struct with block scope
fun test_struct_scope(): i32 {
    let result: i32 = 0;
    
    {
        let p: Point = Point { x: 10.0, y: 20.0 };
        if (p.x > 5.0) {
            result = 1;
        }
    }
    
    return result;
}

// Test 10: Vec3 struct (3 fields)
fun test_vec3(): i32 {
    let v: Vec3 = Vec3 { x: 1.0, y: 2.0, z: 3.0 };
    
    v.x = v.x + 1.0;
    v.y = v.y + 1.0;
    v.z = v.z + 1.0;
    
    if (v.x > 1.0) {
        if (v.y > 2.0) {
            if (v.z > 3.0) {
                return 1;
            }
        }
    }
    return 0;
}

fun main(): i32 {
    let passed: i32 = 0;
    
    passed = passed + test_basic_struct();
    passed = passed + test_field_assignment();
    passed = passed + test_struct_pointer();
    passed = passed + test_modify_through_pointer();
    passed = passed + test_heap_struct();
    passed = passed + test_multiple_structs();
    passed = passed + test_mixed_types();
    passed = passed + test_struct_in_loop();
    passed = passed + test_struct_scope();
    passed = passed + test_vec3();
    
    // Should return 10 if all tests pass
    return passed;
}
